#!/usr/bin/env python3
'''
Controls the build process for this site. Use this script for all builds.

It also manages git pushes to both repositories.
'''

import argparse
import json
import os
import re
import shutil
import sys
import textwrap
from subprocess import call, check_call, CalledProcessError

if os.name == 'nt': # Make the print command automatically flush in Windows.
                    # Otherwise, nothing will appear until exit.
    import functools
    print = functools.partial(print, flush=True)

build_dir = ''
config = None
verbosity = 0

def is_build_dir(dirname):
    try:
        d = os.listdir(dirname)
        return all(i in d for i in ['build_config_sample.json',
            'minify_html_js.py', 'build_dev.sh', 'clean.sh', 'deploy.sh'])
    except (FileNotFoundError, NotADirectoryError):
        return False

def str_wrap(string, kind='normal', indent=0, initial_offset=0):
    cols, lines = shutil.get_terminal_size()
    cols = min(cols, 100)
    if kind == 'help':
        # The width of argparse's left margin for help text, minus 1 for
        # scrollbar padding on Windows' cmd.exe.
        cols = max(cols-23-1, 10)
    out = []
    for paragraph in re.split(r'\r?\n\r?\n', textwrap.dedent(string)):
        paragraph = re.sub(r'[\s]+', ' ', paragraph.strip())
        lines = textwrap.wrap(paragraph, width=cols,
                     replace_whitespace=True, break_long_words=False,
                     initial_indent=' '*indent, subsequent_indent=' '*indent)
        out.append('\n'.join(lines))
    out = '\n\n'.join(out).rstrip()
    if kind == 'help':
        return out + '\n\n'
    else:
        return out + '\n'

def clean(dry_run=False):
    if verbosity >= 0:
        print('Cleaning...')
    cmd = [os.path.join(build_dir, 'clean.sh'), build_dir]
    if os.name == 'nt':
        cmd.insert(0, 'bash')
    if dry_run:
        print(f'Would call {cmd}')
        return True
    result = call(cmd)
    return True if result == 0 else False

def launch_apache(dry_run=False):
    if os.name != 'nt':
        print("Unable to launch Apache on this system.")
        return False
    elif 'xampp_path' not in config.keys():
        with open(os.path.join(build_dir, 'build_config_sample.json')) as f:
            config['xampp_path'] = json.loads(f.read())['xampp_path']
        print('\n' + str_wrap(f'''
            WARNING: Not configured. Please set the "xampp_path" option in the
            config file ("_build_config.json"). Using the default path
            ({config['xampp_path']}), which may or may not work.
            '''))
    elif ' ' in config['xampp_path']:
        if verbosity >= 0:
            print('\n' + str_wrap(f'''
                WARNING: The configured server path ({config['xampp_path']})
                contains one or more spaces. Though it is untested, it's likely
                that this can't be made to work as the Windows command used to
                launch the server doesn't like the server path to be
                quoted.'''))
    if verbosity >= 0:
        print('Launching server...')
    cmd = ['cmd', '/C', f'start {config["xampp_path"]} /run']
    if dry_run:
        print(f'Would call {cmd}')
        return True
    result = call(cmd)
    return True if result == 0 else False

def update_ctags(dry_run=False):
    cmd = ['ctags', '-R', '--exclude=_site', '.']
    if dry_run:
        print(f'Would call {cmd}')
        return True
    result = call(cmd)
    return True if result == 0 else False

def build(dev, incremental=True, watch=False, serve=False, dry_run=False):
    mode = 'serve' if serve else 'build'
    which = 'build_production.sh'
    if dev:
        which = 'build_dev.sh'
    else:
        success = clean(dry_run)
        if not success:
            return False
    update_ctags(dry_run)
    args = [os.path.join(build_dir, '{}'.format(which)), mode]
    if os.name == 'nt':
        args.insert(0, 'bash')
    args.append(build_dir)
    if incremental:
        args.append('--incremental')
    if watch and mode == 'build':
        args.append('--watch')
    if verbosity == 1:
        print('Calling `{}`...'.format(' '.join(args)))
    try:
        if dry_run:
            print(f'Would call {args}')
        else:
            check_call(args)
        if not dev or (not watch and not serve and not incremental):
            return minify(dry_run)
    except CalledProcessError:
        return False
    except KeyboardInterrupt:
        if verbosity >= 0:
            print('\nExiting `{}`.'.format(' '.join(args)))
        return True if (watch or serve) else False
    else:
        return True

def minify(dry_run=False):
    if verbosity >= 0:
        print('Minifying...')
    cmd = [os.path.join(build_dir, 'minify.sh'), build_dir, config.get('minify_options', '')]
    if dry_run:
        cmd.append('--dry-run')
    if os.name == 'nt':
        cmd.insert(0, 'bash')
    try:
        check_call(cmd)
    except CalledProcessError:
        return False
    else:
        return True

def deploy(args, dry_run=False):
    if verbosity >= 0:
        print('Running deploy script...')
    cmd = [os.path.join(build_dir, 'deploy.sh'), build_dir, '_site']
    cmd += ['--config', args.deploy_config]
    if dry_run:
        cmd.append('--dry-run')
    if os.name == 'nt':
        cmd.insert(0, 'bash')
    try:
        check_call(cmd)
    except CalledProcessError:
        return False
    else:
        return True

def git_push(*upstreams, dry_run=False):
    if verbosity >= 0:
        print('Pushing to: {}'.format(' '.join(upstreams)))
    switch = '--quiet' if verbosity == -1 else ''
    if verbosity == 1:
        switch = '--verbose'
    try:
        for upstream in upstreams:
            call_lst = ['git', 'push']
            if len(switch) > 0:
                call_lst.append(switch)
            if dry_run:
                call_lst.append('--dry-run')
            call_lst.append(upstream)
            check_call(call_lst)
    except CalledProcessError:
        return False
    else:
        return True

def parse_args():
    def jekyll_directory(s):
        if verbosity == 1:
            print(os.path.basename(sys.argv[0]))
        if not os.path.isdir(s):
            raise argparse.ArgumentTypeError('\n' + str_wrap('''
                The directory "{}" doesn't exist.'''.format(s),
                indent=8))
        files = os.listdir(s)
        if '_includes' not in files or '_config.yml' not in files:
            raise argparse.ArgumentTypeError('\n' + str_wrap('''
                The directory "{}" doesn't appear to be a Jekyll site source
                directory. If you didn't pass the -J/--jekyll_dir argument, this
                error is caused by your current working directory not being a
                Jekyll site source directory. Either change directory or pass
                -J.
                '''.format(s),
                indent=8))
        return os.path.abspath(s)

    def json_file(s):
        if s is None:
            return None
        try:
            with open(s) as f:
                json.loads(f.read())
            return s
        except (FileNotFoundError, IsADirectoryError, json.JSONDecodeError):
            raise argparse.ArgumentTypeError(f"The file {s} isn't a valid JSON config file!")

    dev = 'Do a development build. This is the default unless --deploy is given.'
    prod = 'Do a production build.'
    deploy = 'Do a build, then deploy. Implies --production unless --dev is specified.'
    clean = 'Clean the build dir.'
    incr = 'Disable incremental builds. Only applies to development builds.'
    watch = "Don't watch for changes. Only applies to development builds. Ignored when deploying or serving."
    serve = 'After building, run Jekyll\'s built-in server. Ignored when deploying.'
    push = 'Does a `git push` to each remote configured herein. All other options are ignored when this is in effect.'
    xampp = 'Launch Apache, which must have been previously configured on the machine and live at C:\\xampp.'
    ctags = 'Update the tags file.'
    jdir = 'Use this directory as the Jekyll source directory. Default: the current working directory.'
    epilog = 'When run with no arguments, this script runs a development build, passing Jekyll the --watch and --incremental arguments.'
    verbose = 'Print all available debugging information'
    deploy_cfg = 'Path to the deploy configuration file. Default: _deploy.json'
    dry_run = 'Do a dry run; don\'t actually change anything.'
    silent = 'Print minimal information'

    parser = argparse.ArgumentParser(description=__doc__, epilog=epilog,
            usage='%(prog)s [options]', add_help=False)
    add = parser.add_argument
    g = parser.add_argument_group(title='Mode', description='At most one of these arguments may be given:')
    group = g.add_mutually_exclusive_group()
    gadd = group.add_argument
    o = parser.add_argument_group(title='Other arguments')
    oadd = o.add_argument
    v = parser.add_argument_group(title="Verbosity", description='At most one of these arguments may be given:')
    vgroup = v.add_mutually_exclusive_group()
    vadd = vgroup.add_argument

    gadd('-d', '--dev', dest='no_dev', action='store_false', help=dev)
    gadd('-p', '--production', action='store_true', help=prod)
    gadd('-c', '--clean', action='store_true', help=clean)
    gadd('-g', '--git-push', dest='push', action='store_true', help=push)
    gadd('-S', '--apache', action='store_true', help=xampp)
    gadd('-t', '--ctags', action='store_true', help=ctags)
    oadd('-D', '--deploy', action='store_true', help=deploy)
    oadd('-i', '--no-incremental', dest='incremental', action='store_false', help=incr)
    oadd('-s', '--serve', action='store_true', help=serve)
    oadd('-w', '--no-watch', dest='watch', action='store_false', help=watch)
    oadd('-J', '--jekyll-dir', type=jekyll_directory, default=os.getcwd(), help=jdir)
    oadd('-z', '--deploy-config', type=json_file, default=None, help=deploy_cfg)
    oadd('-n', '--dry-run', action='store_true', help=dry_run)
    oadd('-h', '--help', action='help', help="Show this help message and exit.")
    vadd('-q', '--quiet', action='store_true', help=silent)
    vadd('-v', '--verbose', action='store_true', help=verbose)

    return parser.parse_args()

def main():
    args = parse_args()
    dry_run = args.dry_run
    global verbosity
    verbosity = 1 if args.verbose else 0
    if args.quiet:
        verbosity = -1
    os.environ['JEKYLL_BUILD_VERBOSITY'] = str(verbosity)
    if verbosity > 0:
        print("os.environ: " + str(os.environ))
    elif verbosity == 0:
        print("Python sees this OS as: {}".format(os.name))
    if dry_run and verbosity >= 0:
        print("Dry run enabled")
    global build_dir
    global config
    config_file = '_build_config.json'
    if not args.deploy_config:
        args.deploy_config = '_deploy.json'
    build_dir = os.path.dirname(os.path.realpath(__file__))
    if not is_build_dir(build_dir):   # Sanity check
        error_message = '\n' + str_wrap(
                '''ERROR: The calculated build dir is "{}", but this isn't a
                real build dir. This is a bug in the build script.''')
        if os.path.islink(__file__):
            build_dir = os.path.dirname(os.path.realpath(os.readlink(__file__)))
            if not is_build_dir(build_dir):
                exit(error_message.format(build_dir))
            else:
                if verbosity == 1:
                    print('NOTICE: Corrected build dir.')
        else:
            exit(error_message.format(build_dir))
    if verbosity >= 0:
        print(f'Jekyll source directory: {args.jekyll_dir}')
        print(f'Build scripts located in: {build_dir}')
    os.chdir(args.jekyll_dir)
    if not os.path.isfile(config_file):
        exit(str_wrap(f'''
            Couldn't find the configuration file "{config_file}". Please create
            it before continuing. You can find an example at
            "{os.path.join(build_dir, 'build_config_sample.json')}".
            '''))
    with open(config_file) as f:
        config = json.loads(f.read())
    if args.push:
        targets = config.get('git_remotes', ['origin'])
        success = git_push(*targets, dry_run=dry_run)
        code = 0 if success else 4
        exit(code)
    elif args.clean:
        success = clean(dry_run)
        code = 0 if success else 3
        exit(code)
    elif args.apache:
        success = launch_apache(dry_run)
        code = 0 if success else 5
        exit(code)
    elif args.ctags:
        success = update_ctags(dry_run)
        code = 0 if success else 9
        exit(code)
    elif args.deploy:
        d = {'dev': False}
        args.serve = False
        args.watch = False
        if args.no_dev: # we want to deploy a production build
            args.incremental = not args.incremental
        else:
            d['dev'] = True
        d['incremental'] = args.incremental
        success = build(**d, dry_run=dry_run)
        if success:
            success = deploy(args, dry_run)
            code = 0 if success else 2
            exit(code)
        else:
            exit(1)
    else:
        d = {
            'dev': False if args.production else True,
            'incremental': args.incremental,
            'watch': args.watch,
            'serve': args.serve
        }
        success = build(**d, dry_run=dry_run)
        code = 0 if success else 1
        exit(code)

if __name__ == '__main__':
    main()
